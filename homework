Django生命周期
    a.wsgi
        wsgi：协议
        wsgiref:是python实现wsgi协议的一个模块，模块的本质：一个socket服务端(django)
        werkzeug:是python实现wsgi协议的一个模块，模块的本质：一个socket服务端(Flask框架)
        tornado:是python实现wsgi协议的一个模块，模块的本质：一个socket服务端(Flask框架)
        uwsgi:是实现了wsgi协议的一个模块，模块本质：一个socket服务器

Django生命周期:(rest_framework)
        wsgi->中间件->路由匹配->反射视图方法




作业：
    1.中间件
        最多几个方法？
            process_request、
            process_view、
            process_response、
            process_exception、
            process_render_template
        用中间件做过什么？
            利用它实现csrf_token，利用process_view中处理或装饰器
                为什么用process_view而不用process_request?
                    因为用process_request的话如果用的是装饰器这需要到达路由匹配到函数才能访问的装饰器
                    而process_view还没有路由匹配到函数就处理了
            --基于角色的权限控制
            --用户认证
            --csrf(说原理）
            --session(说原理）
            --黑名单
            --日志记录



    2.csrf
    3.CBV
    4.restful
        3.1、10条规范
        3.2、自己的认识
    5.djangorestframework
        5.1、如何验证（基于数据库实现用户认证）
        5.2、源码流程（面向对象回顾流程）


一、认证

    认证的梳理：
        1.使用
            1.1、创建类：继承BaseAuthentication：实现：authenticate这个方法
            1.2、返回值：
                1.2.1、None，下一个认证执行
                1.2.3、抛出异常，raise exceptions.AuthenticationFailed('用户认证失败')
                1.2.3、返回元组，（元素1，元素2） 分别赋值给request.user，request.auth
            1.3、局部使用：
                需要认证的View:加上authentication_classes = [Authentication,]
            1.4、全局使用：（使用路径）
                REST_FRAMEWORK = {
                    # 全局使用的认证类
                    "authentication_classes": ['app01.utils.auth.Authentication'],
                    # 匿名用户设置
                    # "UNAUTHENTICATED_USER": lambda :"匿名用户"
                    "UNAUTHENTICATED_USER": None,           #推荐使用，匿名，因为request.user = None
                    "UNAUTHENTICATED_TOKEN": None,          # 匿名，因为request.auth = None
                }
        2.源码流程
            dispath->封装request->获取定义的认证类（全局/局部）,通过列表生成器创建对象->initial->perform_authentication->request.user


二、权限
    问题：不同的视图不同的权限
    1.基本使用
        class MyPermission(object):
            def has_permission(self, request, view):
                print(request.user)
                if request.user.user_type != 1:
                    return False
                return True
        class OrderView(APIView):
            # authentication_classes = [Authentication,]
            permission_classes = [MyPermission,]

            def get(self, request, *args, **kwargs):
                ret = {'code': 10000,'msg': None, 'data':None}
                try:
                    ret['data'] = ORDER_DICT
                except Exception as e:
                    pass
                return JsonResponse(ret)
    2.源码流程
        。。。

    3.权限梳理
        3.1、基本使用
            3.1.1、类，必须继承：BasePermission，必须实现：has_permission方法

                from rest_framework.permissions import BasePermission

                class SvipPermission(BasePermission):
                    message = "必须是SVIP才能访问"

                    def has_permission(self, request, view):
                        # print(request.user)
                        if request.user.user_type != 3:
                            return False
                        return True
            3.1.2、返回值，True,有权访问，False,无权访问
            3.1.3、局部使用：
                需要认证的View:加上permission_classes = [SvipPermission,]
            3.1.4、全局使用：（使用路径）
                REST_FRAMEWORK = {
                "DEFAULT_PERMISSION_CLASSES":['app01.utils.permission.SvipPermission',],
                }
        3.2、源码流程

三、版本
    1.URL中通过GET传参数
    2.在URL中传参（推荐使用,正则表达式）

四、解析器
    1.前戏：django:request.POST/ request.body
        1.1、请求头要求：
            Content-Type:application/x-www-form-urlencoded
            PS：如果请求头中的Content-Type:application/x-www-form-urlencoded，request.POST中才有值（去request.body中解析数据）
        1.2、数据格式要求：
            name=alex&age=18&gender=男
        如：
            a.form表单提交：默认带的是Content-Type:application/x-www-form-urlencoded
            b.ajax提交：

                $.ajax({
                    url:...
                    type:POST
                    data:{'name':'alex','age':18}    # 内部转化成name=alex&age=18&gender=男，携带Content-Type:application/x-www-form-urlencoded提交
                    ...
                })
                情况一：
                $.ajax({
                    url:...
                    type:POST
                    headres:{'Content-Type':'application/json'}
                    data:{'name':'alex','age':18}   # 内部转化成name=alex&age=18&gender=男
                    ...                             # body有值，POST没有
                })
                情况二：
                $.ajax({
                    url:...
                    type:POST
                    headres:{'Content-Type':'application/json'}
                    data:JSON.stringfy({'name':'alex','age':18})    # {'name':'alex','age':18}
                    ...                                             # body有值，POST没有，但是可以用json.loads(request.body)得到
                })

    2.rest-framework解析器，对请求体进行解析
        2.1、全局配置
        2.2、使用
            class ParserView(APIView):
            """
            JSONParser:表示只能解析content-type:application/json头,(最常用)
            FormParser:表示只能解析content-type:application/x-www-form-urlencoded头
            """

            def post(self, request, *args, **kwargs):
                """
                允许用户发送JSON格式数据
                    a.content-type:application/json
                    b.{'name':'alex','age':18}
                :param request:
                :param args:
                :param kwargs:
                :return:
                """
                # 获取解析后的结果，用了request.data才去解析
                """
                    1.获取用户请求
                    2.获取用户请求体
                    3.根据用户请求体和parser_classes = [JSONParser,]中支持的请求头进行比较
                    4.JSONParser对象处理请求体
                    5.request.data来触发的
                """
                print(request.data)

                return  HttpResponse('ParserView')
    3.源码流程&本质：
        3.1、本质
            请求体
            状态码
            请求方法
        3.2、源码流程
            -dispath:request封装
            -request.data

五、序列化
    （1）序列化：
        1.写类，继承于Serializer(自定义生成字段)、ModelSerializer(自动生成字段，也是继承于Serializer)
        2.字段：
            2.1、name=serializers.CharField(source="xxx.xx.xx")
            2.2、roles = serializers.SerializerMethodField()  # 自定义显示

                    class UserInfoSerializer(serializers.ModelSerializer):
                        roles = serializers.SerializerMethodField()  # 字段自定义显示
                        class Meta:
                            model = UserInfo
                            # fields = "__all__"
                            fields = ['id', 'username', 'password', 'xxx', 'roles', 'group']

                        def get_roles(self, row):
                            role_obj_list = row.roles.all()
                            ret = []
                            for item in role_obj_list:
                                ret.append({'id':item.id, 'name':item.name})
                            return ret
            2.3、自定义类不常用
        3.自动化序列化连表
            class UserInfoSerializer(serializers.ModelSerializer):
                class Meta:
                    model = UserInfo
                    fields = "__all__"
                    # fields = ['id', 'username', 'password', 'xxx', 'roles', 'group']
                    depth = 1  # 官方建议0~10，尽量不要超过3层
        4.生成链接
            class UserInfoSerializer(serializers.ModelSerializer):
                group = serializers.HyperlinkedIdentityField(view_name='group', lookup_field='group_id', lookup_url_kwarg='pk')

                class Meta:
                    model = UserInfo
                    fields = "__all__"
                    fields = ['id', 'username', 'password', 'roles', 'group']
                    depth = 0  # 官方建议0~10，尽量不要超过3层

            class UserInfoView(APIView):
                """用户中心（普通用户，vip）"""
                # authentication_classes = [Authentication, ]
                # 当前permission_classes存在就不会去取配置文件里的设置
                permission_classes = [VipPermission, ]

                def get(self, request, *args, **kwargs):

                    users = UserInfo.objects.all()
                    ser = UserInfoSerializer(instance=users, many=True, context={'request': request})
                    # print(ser.data)
                    ret = json.dumps(ser.data, ensure_ascii=False)
                    return HttpResponse(ret)
        5.源码流程
            对象，Serializer类处理
            QuerySet，ListSerializer类处理
            # ser.data入口
    (2)请求数据校验
        class XXXValidator(object):
            def __init__(self, base):
                self.base = base

            def __call__(self, value):
                if not value.startswith(self.base):
                    message = '名称必须以 %s 开头' % self.base
                    raise serializers.ValidationError(message)

        class UserGroupSerializer(serializers.Serializer):
            name = serializers.CharField(error_messages={'required': '姓名不能为空'}, validators=[XXXValidator('nzb'),])

        class UserGroupView(APIView):

            authentication_classes = []
            permission_classes = []

            def post(self, request, *args, **kwargs):

                # print(request.data)
                ser = UserGroupSerializer(data=request.data)
                if ser.is_valid():
                    print(ser.validated_data)
                    # 单独取某些
                    print(ser.validated_data['name'])
                else:
                    print(ser.errors)
                return HttpResponse('提交数据')

六、分页
    数据量大时，怎么规避，1、只显示200页，2、只有上一页和下一页

七、视图

八、路由

九、渲染器

十、django组件：contenttype


__init__和__new__的区别：
__new__：是返回对象
__init__：是__new__返回的对象的构造方法

















